{
    "language": "Solidity",
    "settings": {
        "viaIR": true,
        "optimizer": {
            "enabled": true,
            "runs": 200
        },
        "outputSelection": {
            "*": {
                "": [
                    "ast"
                ],
                "*": [
                    "abi",
                    "metadata",
                    "devdoc",
                    "userdoc",
                    "storageLayout",
                    "evm.legacyAssembly",
                    "evm.bytecode",
                    "evm.deployedBytecode",
                    "evm.methodIdentifiers",
                    "evm.gasEstimates",
                    "evm.assembly"
                ]
            }
        }
    },
    "sources": {
        "SimplePools.sol": {
            "content": "pragma solidity ^0.8.17;\r\n// SPDX-License-Identifier: GPL-3.0-or-later\r\n// Simple Pools smart contract DeFi exchange.\r\n// Copyright (C) 2023 Simple Pools\r\n\r\n// This program is free software: you can redistribute it and/or modify it under\r\n// the terms of the GNU General Public License as published by the Free Software \r\n// Foundation, either version 3 of the License, or (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful, but WITHOUT \r\n// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS \r\n// FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License along with this \r\n// program. If not, see <https://www.gnu.org/licenses/>.\r\n\r\n/**\r\n * Simple Pools\r\n * https://simplepools.org/\r\n * DeFi made simple.\r\n */\r\ncontract SimplePools {\r\n\r\n    /**\r\n     * Main structure for the simple DeFi pool.\r\n     */ \r\n    struct Pool {\r\n\r\n        /**\r\n         * The ID of the pool.\r\n         */\r\n        uint64 poolId;\r\n\r\n        /**\r\n         * Flag indicating whether asset1 is the native blockchain currency.\r\n         */\r\n        bool isAsset1NativeBlockchainCurrency;\r\n\r\n        /**\r\n         * The ERC20 contract address of the first asset in the pool\r\n         * (the initially offered asset for selling).\r\n         * Used only if isAsset1NativeBlockchainCurrency is false.\r\n         */\r\n        address asset1;\r\n\r\n        /**\r\n         * Flag indicating whether asset2 is the native blockchain currency.\r\n         */\r\n        bool isAsset2NativeBlockchainCurrency;\r\n\r\n        /**\r\n         * The ERC20 contract address of the second asset in the pool\r\n         * (the initially asked asset for buying).\r\n         * Used only if isAsset2NativeBlockchainCurrency is false.\r\n         */\r\n        address asset2;\r\n\r\n        /**\r\n         * The current amount of asset1 in the pool.\r\n         */\r\n        uint256 asset1Amount;\r\n\r\n        /**\r\n         * The current amount of asset2 in the pool.\r\n         */\r\n        uint256 asset2Amount;\r\n\r\n        /**\r\n         * Initial asked price in asset2 requested for the whole asset1.\r\n         */\r\n        uint256 asset2InitiallyAskedAmount;\r\n\r\n        /**\r\n         * Maximum percent of asset1 that can be bought with one transaction.\r\n         * For example when the pool is used like a limit order in an orderbook\r\n         * the value of maxBuyAsset1PercentPerTransaction can be 100% so the \r\n         * order can be filled with one transaction. But if a newly created\r\n         * asset for which the whole supply is added to a simple pool the value\r\n         * of maxBuyAsset1PercentPerTransaction can be 1% (or 5%, 10%, 15%, 50%),\r\n         * depending on the use case.\r\n         */\r\n        uint8 maxBuyAsset1PercentPerTransaction;\r\n\r\n        /**\r\n         * The constantProduct equals (asset1Amount * (asset2Amount + asset2InitiallyAskedAmount))\r\n         * it is used to calculate the amount of bought and sold assets on exchange transactions.\r\n         * This is an invariant hold after each transaction in the pool when the flag isConstantPrice\r\n         * is set to false. If isConstantPrice is true then this value is ignored and only \r\n         * asset2InitiallyAskedAmount and initialAsset1Amount is used for price calculation.\r\n         */\r\n        uint256 constantProduct; // (A1*(A2+IA2)) = constantProduct\r\n\r\n        /**\r\n         * Flag indicating whether the pool is with changing price for asset in asset2.\r\n         * If the flag is \"true\" then the price will be always the same and constantProduct\r\n         * is ignored. Otherwise the pool changes the price on each transaction to keep the\r\n         * invariant (A1*(A2+IA2)) = constantProduct.\r\n         */\r\n        bool isConstantPrice;\r\n\r\n        /**\r\n         * The inital asset1 amount value when the pools was created. It is used to calculate\r\n         * the amount of bought and sold assets when the flag \"isConstantPrice\" is set to \"true\". \r\n         */\r\n        uint256 initialAsset1Amount;\r\n\r\n        /**\r\n         * The owner of the pool can take all assets, change maxBuyAsset1PercentPerTransaction,\r\n         * change the constantPrice when the pool is not locked. Also the pool owner takes half\r\n         * of the transaction taxes for each transaction. The other half is taken by the contract\r\n         * owner.\r\n         */\r\n        address payable poolOwner;\r\n\r\n        /**\r\n         * Flag indicating whether the pool is locked. Locked pools cannot be unlocked.\r\n         */\r\n        bool isLocked;\r\n\r\n        /**\r\n         * Flag indicating whether all assets (asset1 and asset1) are taken from\r\n         * the pool by the pool owner.\r\n         * Empty pools cannot be used. \r\n         * Locked pools cannot be emptied.\r\n         */\r\n        bool isEmpty;\r\n    }\r\n\r\n    /**\r\n     * List with all the pools in the smart contract.\r\n     */\r\n    Pool[] public _pools;\r\n\r\n    /**\r\n     * Each transaction with the smart contract is associated with a signle pool.\r\n     * This array keeps for each transaction with what pool it was associated.\r\n     * This is useful to sync the state of all pools in an indexed Database.\r\n     * \r\n     * The procedure for syncing pool states is the following:\r\n     * The Database stores the index of the last transaction with which it has synced\r\n     * all pools. Then it gets the current state of transactions in the smart contract\r\n     * by querying _allTransactionsPoolIds.length, and then get the only the indexes of the\r\n     * pools that were modified by the lates transactions (not synced with the DB), and\r\n     * sync the states only for these pools.\r\n     */\r\n    uint64[] _allTransactionsPoolIds;\r\n\r\n    /*\r\n     * Note: First the asset contract (if not native) have to allow the asset for spending \r\n     * by the SimplePools contract and then the operations can be performed.\r\n     */\r\n\r\n    /**\r\n     * Creates a simple pool.\r\n     * For the documentation of each parameter check the Pool structure definition.\r\n     * \r\n     * @param poolCreatorAddress the address of the pool creator\r\n     * @param isAsset1Native                         *\r\n     * @param asset1                                 *\r\n     * @param isAsset2Native                         *\r\n     * @param asset2                                 *\r\n     * @param asset1Amount                           *\r\n     * @param asset2InitiallyAskedAmount             *\r\n     * @param maxBuyAsset1PercentPerTransaction      *\r\n     * @param isConstantPrice                        *\r\n     */\r\n    function createPool(\r\n        address poolCreatorAddress,\r\n        bool isAsset1Native,\r\n        IERC20 asset1,\r\n        bool isAsset2Native,\r\n        IERC20 asset2,\r\n        uint256 asset1Amount,\r\n        uint256 asset2InitiallyAskedAmount,\r\n        uint8 maxBuyAsset1PercentPerTransaction, \r\n        bool isConstantPrice\r\n    ) external payable {\r\n        uint256 nativeAmountRequired = contractTransactionTax + (isAsset1Native ? asset1Amount : 0);\r\n        require(msg.value >= nativeAmountRequired, \"Lower than the required transaction value\");\r\n\r\n        uint64 poolId = uint64(_pools.length);\r\n        _allTransactionsPoolIds.push(poolId);\r\n        if (isAsset1Native) {\r\n            payable(this).transfer(asset1Amount);\r\n            contractOwner.transfer(msg.value - asset1Amount);\r\n        } else {\r\n            asset1.transferFrom(poolCreatorAddress, address(this), asset1Amount);\r\n            contractOwner.transfer(msg.value);\r\n        }\r\n        _pools.push().poolId = poolId;\r\n        Pool storage pool = _pools[poolId];\r\n        pool.asset1 = address(asset1);\r\n        pool.asset1Amount = asset1Amount;\r\n        pool.asset2 = address(asset2);\r\n        pool.asset2Amount = 0;\r\n        pool.isAsset1NativeBlockchainCurrency = isAsset1Native;\r\n        pool.isAsset2NativeBlockchainCurrency = isAsset2Native;\r\n        pool.asset2InitiallyAskedAmount = asset2InitiallyAskedAmount;\r\n        pool.maxBuyAsset1PercentPerTransaction = maxBuyAsset1PercentPerTransaction;\r\n        pool.isConstantPrice = isConstantPrice;\r\n        pool.constantProduct = asset1Amount * asset2InitiallyAskedAmount;\r\n        pool.initialAsset1Amount = asset1Amount;\r\n        pool.poolOwner = payable(poolCreatorAddress);\r\n        pool.isLocked = false;\r\n        pool.isEmpty = false;\r\n    }\r\n\r\n    /**\r\n     * Exchanges asset for asset from a simple pool.\r\n     * \r\n     * @param personExecutingTheExchange address of the person executing the exchange\r\n     * @param poolId the poolId for the pool where the exchange happens\r\n     * @param isBuyingAsset1 boolean flag indicating whether asset1 is requested\r\n     *            for buying in the transaction. If the value of the flag is true\r\n     *            then asset2 from the pool is sold for asset1. Otherwise if the\r\n     *            value of the flag is false then asset1 from the pool is sold for asset2.\r\n     * @param sellAmount the amount of asset to sell for the exchange\r\n     * @param minReceiveAssetToBuyAmount the minimum amount received from assetToBuy.\r\n     *        This param ensures that front-runner bots cannot take advantage of the\r\n     *        transaction. This should be set automatically by simplepools.org or\r\n     *        calculated manually\r\n     * @return the actual amount bought from the transaction\r\n     */\r\n    function exchangeAsset(\r\n        address personExecutingTheExchange,\r\n        uint64 poolId,\r\n        bool isBuyingAsset1,\r\n        uint256 sellAmount, \r\n        uint256 minReceiveAssetToBuyAmount\r\n    ) external payable returns (uint256) {\r\n        require(poolId < _pools.length, \"Invalid poolId\");\r\n        Pool storage pool = _pools[poolId];\r\n        require(!pool.isEmpty, \"Pool is empty\");\r\n        _allTransactionsPoolIds.push(poolId);\r\n\r\n        if (isBuyingAsset1) {\r\n            uint256 amountOut;\r\n            if (pool.isConstantPrice) {\r\n                // amountOut = (sellAmount*initialAsset1Amount)/asset2InitiallyAskedAmount\r\n                amountOut = Math.mulDiv(sellAmount, pool.initialAsset1Amount, pool.asset2InitiallyAskedAmount);\r\n            } else {\r\n                // amountOut = asset1Amount - constantProduct/(asset2InitiallyAsked+asset2Amount+sellAmount)\r\n                amountOut = pool.asset1Amount -\r\n                    pool.constantProduct / (pool.asset2InitiallyAskedAmount + pool.asset2Amount + sellAmount);\r\n            }\r\n            // maxBuyAsset1PercentPerTransaction correction of amountOut\r\n            amountOut = Math.min(amountOut, \r\n                    Math.mulDiv(pool.asset1Amount, pool.maxBuyAsset1PercentPerTransaction, 100));\r\n            require(minReceiveAssetToBuyAmount <= amountOut,\"minReceive is less than calcualted amount\");\r\n            // complete the transaction now\r\n\r\n            // transfer asset2 to the pool\r\n            uint256 taxDivided = contractTransactionTax / 2;\r\n            if (pool.isAsset2NativeBlockchainCurrency) {\r\n                require(msg.value >= sellAmount + contractTransactionTax, \"lower transaction value\");\r\n                payable(this).transfer(sellAmount); // move funds to the pool\r\n                pool.poolOwner.transfer(taxDivided);\r\n                contractOwner.transfer(msg.value - sellAmount - taxDivided);\r\n            } else {\r\n                require(msg.value >= contractTransactionTax, \"lower transaction value\");\r\n                IERC20(pool.asset2).transferFrom(personExecutingTheExchange, address(this), sellAmount);\r\n                pool.poolOwner.transfer(taxDivided);\r\n                contractOwner.transfer(msg.value - taxDivided);\r\n            }\r\n            pool.asset2Amount += sellAmount;\r\n            // transfer asset1 from the pool\r\n            if (pool.isAsset1NativeBlockchainCurrency) {\r\n                payable(personExecutingTheExchange).transfer(amountOut);\r\n            } else {\r\n                IERC20(pool.asset1).transfer(personExecutingTheExchange, amountOut);\r\n            }\r\n            pool.asset1Amount -= amountOut;\r\n\r\n            pool.constantProduct = (pool.asset1Amount) * (pool.asset2Amount + pool.asset2InitiallyAskedAmount);\r\n            return amountOut;\r\n        } else { // is buying asset2 by selling asset1\r\n            require(pool.asset2Amount > 0, \"zero amount of asset2 for buy in the pool\");\r\n            uint256 amountOut;\r\n            if (pool.isConstantPrice) {\r\n                // amountOut = (sellAmount * asset2InitiallyAskedAmount) / initialAsset1Amount\r\n                amountOut = Math.mulDiv(sellAmount, pool.asset2InitiallyAskedAmount, pool.initialAsset1Amount);\r\n            } else {\r\n                amountOut = pool.asset2InitiallyAskedAmount + pool.asset2Amount -\r\n                        pool.constantProduct / (pool.asset1Amount + sellAmount);\r\n            }\r\n            // sell only from the available amount in the pool\r\n            amountOut = Math.min(amountOut, pool.asset2Amount);\r\n            require(minReceiveAssetToBuyAmount <= amountOut,\"minReceive is more than calcualted amount\");\r\n            // complete the transaction now\r\n            uint256 taxDivided = contractTransactionTax / 2;\r\n            // transfer asset1 to the pool\r\n            if (pool.isAsset1NativeBlockchainCurrency) {\r\n                require(msg.value >= sellAmount + contractTransactionTax, \"lower transaction value\");\r\n                payable(this).transfer(sellAmount);\r\n                pool.poolOwner.transfer(taxDivided);\r\n                contractOwner.transfer(msg.value - sellAmount - taxDivided);\r\n            } else {\r\n                require(msg.value >= contractTransactionTax, \"lower transaction value\");\r\n                IERC20(pool.asset1).transferFrom(personExecutingTheExchange, address(this), sellAmount);\r\n                pool.poolOwner.transfer(taxDivided);\r\n                contractOwner.transfer(msg.value - taxDivided);\r\n            }\r\n            pool.asset1Amount += sellAmount;\r\n            // transfer asset2 from the pool\r\n            if (pool.isAsset2NativeBlockchainCurrency) {\r\n                payable(personExecutingTheExchange).transfer(amountOut);\r\n            } else {\r\n                IERC20(pool.asset2).transfer(personExecutingTheExchange, amountOut);\r\n            }\r\n            pool.asset2Amount -= amountOut;\r\n            pool.constantProduct = (pool.asset1Amount) * (pool.asset2Amount + pool.asset2InitiallyAskedAmount);\r\n            return amountOut;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Transfers all assets (asset1 and asset2) from a pool to\r\n     * the pool owner. Only callable by the pool owner.\r\n     *\r\n     * @param poolId the poolId of the pool\r\n     */\r\n    function getAllAssetsFromPool(\r\n            uint64 poolId) external payable {\r\n        require(_pools.length > poolId, \"invalid pool id\");\r\n        Pool storage pool = _pools[poolId];\r\n        require(!pool.isLocked, \"pool is locked\");\r\n        require(!pool.isEmpty, \"pool is empty\");\r\n        require(pool.poolOwner == msg.sender, \"only the pool owner can empty pool\");\r\n        _allTransactionsPoolIds.push(poolId);\r\n        require(msg.value >= contractTransactionTax, \"lower tax specified\");\r\n        contractOwner.transfer(msg.value); // transfer the tax to the owner\r\n        if (pool.isAsset1NativeBlockchainCurrency) {\r\n            payable(msg.sender).transfer(pool.asset1Amount);\r\n        } else {\r\n            IERC20(pool.asset1).transfer(msg.sender, pool.asset1Amount);\r\n        }\r\n        pool.asset1Amount = 0;\r\n\r\n        if (pool.isAsset2NativeBlockchainCurrency) {\r\n            payable(msg.sender).transfer(pool.asset2Amount);\r\n        } else {\r\n            IERC20(pool.asset2).transfer(msg.sender, pool.asset2Amount);\r\n        }\r\n        pool.asset2Amount = 0;\r\n        pool.asset2InitiallyAskedAmount = 0;\r\n        pool.isEmpty = true;\r\n    }\r\n\r\n    /**\r\n     * Locks a pool. Only callable by the pool owner.\r\n     * Locked pools cannot be unlocked and the assets cannot be taken from the pool owner.\r\n     *\r\n     * @param poolId the id of the pool\r\n     */\r\n    function lockPool(\r\n            uint64 poolId) external payable {\r\n        require(_pools.length > poolId, \"invalid pool id\");\r\n        Pool storage pool = _pools[poolId];\r\n        require(!pool.isLocked, \"pool is already locked\");\r\n        require(pool.poolOwner == msg.sender, \"only the pool owner can lock a pool\");\r\n        _allTransactionsPoolIds.push(poolId);\r\n        require(msg.value >= contractTransactionTax, \"lower tax specified\");\r\n        contractOwner.transfer(msg.value); // transfer the tax to the owner\r\n        pool.isLocked = true;\r\n    }\r\n\r\n    /**\r\n     * Changes the ownership of a pool. Only callable by the pool owner.\r\n     * If the owner gets compromised and is fast enough, they can transfer the ownership of the pool.\r\n     * \r\n     * @param poolId the id of the pool\r\n     * @param newPoolOwner the address of the new pool owner\r\n     */\r\n    function changeOwner(\r\n            uint64 poolId, \r\n            address newPoolOwner) external payable {\r\n        require(poolId < _pools.length, \"invalid poolId\");\r\n        Pool storage pool = _pools[poolId];\r\n        require(!pool.isLocked, \"pool is locked\");\r\n        require(pool.poolOwner == msg.sender, \"only the pool owner can change ownership\");\r\n        pool.poolOwner = payable(newPoolOwner);\r\n        _allTransactionsPoolIds.push(poolId);\r\n        require(msg.value >= contractTransactionTax, \"lower tax specified\");\r\n        contractOwner.transfer(msg.value); // transfer the tax to the owner\r\n    }\r\n\r\n    /**\r\n     * Changes maxBuyAsset1PercentPerTransaction. Only callable by the pool owner.\r\n     * \r\n     * @param poolId the id of the pool\r\n     * @param newMaxBuyAsset1PercentPerTransaction the new maxBuyAsset1PercentPerTransaction\r\n     */\r\n    function changePoolMaxBuyAsset1PercentPerTransaction(\r\n            uint64 poolId, \r\n            uint8 newMaxBuyAsset1PercentPerTransaction) external payable {\r\n        require(poolId < _pools.length, \"invalid poolId\");\r\n        Pool storage pool = _pools[poolId];\r\n        require(!pool.isLocked, \"pool is locked\");\r\n        require(pool.poolOwner == msg.sender, \r\n                \"only the pool owner can change newMaxBuyAsset1PercentPerTransaction\");\r\n        require(newMaxBuyAsset1PercentPerTransaction <= 100 &&\r\n                    newMaxBuyAsset1PercentPerTransaction > 0, \r\n                    \"invalid max percent per transaction\");\r\n        _pools[poolId].maxBuyAsset1PercentPerTransaction = newMaxBuyAsset1PercentPerTransaction;\r\n        _allTransactionsPoolIds.push(poolId);\r\n        require(msg.value >= contractTransactionTax, \"lower tax specified\");\r\n        contractOwner.transfer(msg.value); // transfer the tax to the owner\r\n    }\r\n\r\n    /**\r\n     * Changes a pool constant product. Only callable by the pool owner.\r\n     * \r\n     * @param poolId the poolId\r\n     * @param newConstantProduct the new constant product\r\n     */\r\n    function changeContantProduct(\r\n            uint64 poolId, \r\n            uint256 newConstantProduct) external payable {\r\n        require(poolId < _pools.length, \"invalid poolId\");\r\n        Pool storage pool = _pools[poolId];\r\n        require(!pool.isLocked, \"pool is locked\");\r\n        require(pool.poolOwner == msg.sender, \"only the pool owner can change the constant product\");\r\n        require(newConstantProduct > 0, \"invalid constant product (only positive numbers)\");\r\n        pool.constantProduct = newConstantProduct;\r\n        _allTransactionsPoolIds.push(poolId);\r\n        require(msg.value >= contractTransactionTax, \"lower tax specified\");\r\n        contractOwner.transfer(msg.value); // transfer the tax to the owner\r\n    }\r\n\r\n    /**\r\n     * Returns whether a pool is locked.\r\n     * \r\n     * @param poolId the id of the pool\r\n     *\r\n     * @return true if the pool is locked\r\n     */\r\n    function isPoolLocked(uint64 poolId) external view returns (bool) {\r\n        return _pools[poolId].isLocked;\r\n    }\r\n\r\n    /**\r\n     * @return number of pools in the smart contract.\r\n     */\r\n    function getPoolsCount() external view returns (uint) {\r\n        return _pools.length;\r\n    }\r\n\r\n    /**\r\n     * Gets the states of the pools in a given range [startPoolIndex, ..., endPoolIndex).\r\n     * Start index is included and end index is not included.\r\n     * \r\n     * @param startPoolIndex the start index\r\n     * @param endPoolIndex the end index\r\n     *\r\n     * @return list of requested pools\r\n     */\r\n    function getPools(\r\n            uint64 startPoolIndex, \r\n            uint64 endPoolIndex\r\n    ) external view returns (Pool[] memory) {\r\n       require(endPoolIndex > startPoolIndex && endPoolIndex <= _pools.length, \"invalid indexes\");\r\n       Pool[] memory pools = new Pool[](endPoolIndex - startPoolIndex);\r\n       for (uint64 i = startPoolIndex; i < endPoolIndex; ++i) {\r\n            pools[i - startPoolIndex] = _pools[i];\r\n       }\r\n       return pools;\r\n    }\r\n    \r\n    /**\r\n     * Gets the states of the pools from a given starting index till the end.\r\n     * \r\n     * @param startPoolIndex the start index\r\n     *\r\n     * @return list of requested pools\r\n     */\r\n    function getPoolsFrom(\r\n            uint64 startPoolIndex) external view returns (Pool[] memory) {\r\n       require(startPoolIndex < _pools.length, \"invalid index\");\r\n       Pool[] memory pools = new Pool[](_pools.length - startPoolIndex);\r\n       for (uint64 i = startPoolIndex; i < _pools.length; ++i) {\r\n            pools[i - startPoolIndex] = _pools[i];\r\n        }\r\n        return pools;\r\n    }\r\n\r\n    /**\r\n     * Returns the states of the pools with the requested indexes.\r\n     * \r\n     * @param indexes the list of requested pool indexes\r\n     * \r\n     * @return list of requested pools\r\n     */\r\n    function getPools(\r\n            uint64[] memory indexes) external view returns (Pool[] memory) {\r\n        Pool[] memory pools = new Pool[](indexes.length);\r\n        for (uint64 i = 0; i < indexes.length; ++i) {\r\n            Pool storage pool = _pools[indexes[i]];\r\n            pools[i] = pool;\r\n        }\r\n        return pools;\r\n    }\r\n\r\n    /**\r\n     * Returns the state of a single pool.\r\n     * \r\n     * @param poolId the id of the requested pool\r\n     * \r\n     * @return the requested pool \r\n     */\r\n    function getPool(uint64 poolId) external view returns (Pool memory) {\r\n        return _pools[poolId];\r\n    }\r\n\r\n    /**\r\n     * Returns the count of all transactions executed with the smart contract.\r\n     */\r\n    function getTransactionsCount() external view returns (uint256) {\r\n        return _allTransactionsPoolIds.length;\r\n    }\r\n\r\n    /**\r\n     * Returns the list of pool indexes of the pools participating in\r\n     * the list of requested transactions in range [startTransactionIndex, ..., endTransactionIndex).\r\n     * \r\n     * @param startTransactionIndex the index of the starting transaction\r\n     * @param endTransactionIndex the index of the last transaction\r\n     *\r\n     * @return the requested list of pool indexes\r\n     */\r\n    function getPoolsForTransactionsWithIndexesBetween(\r\n            uint64 startTransactionIndex,\r\n            uint64 endTransactionIndex\r\n    ) external view returns (uint64[] memory) {\r\n        require(endTransactionIndex > startTransactionIndex && \r\n                endTransactionIndex <= _allTransactionsPoolIds.length, \"invalid indexes\");\r\n        uint64[] memory poolIndexes = new uint64[](endTransactionIndex - startTransactionIndex);\r\n        for (uint64 i = startTransactionIndex; i < endTransactionIndex; ++i) {\r\n            poolIndexes[i - startTransactionIndex] = _allTransactionsPoolIds[i];\r\n        }\r\n        return poolIndexes;\r\n    }\r\n\r\n    /**\r\n     * Returns the list of pool indexes of the pools participating in\r\n     * the list of requested transactions in range [startTransactionIndex, ..., _allTransactionsPoolIds.length).\r\n     * \r\n     * @param startTransactionIndex the index of the starting transaction\r\n     *\r\n     * @return the requested list of pool indexes\r\n     */\r\n    function getPoolsForTransactionsWithIndexesFrom(\r\n            uint64 startTransactionIndex) external view returns (uint64[] memory) {\r\n        require(startTransactionIndex < _allTransactionsPoolIds.length, \"invalid index\");\r\n        uint64[] memory poolIndexes = new uint64[](_allTransactionsPoolIds.length - startTransactionIndex);\r\n        for (uint64 i = startTransactionIndex; i < _allTransactionsPoolIds.length; ++i) {\r\n            poolIndexes[i - startTransactionIndex] = _allTransactionsPoolIds[i];\r\n        }\r\n        return poolIndexes;\r\n    }\r\n\r\n    /**\r\n     * The owner of the contract (the receiver of the taxes).\r\n     */\r\n    address payable public contractOwner;\r\n\r\n    /**\r\n     * Set the initial contract owner to the msg.sender.\r\n     */\r\n    constructor() {\r\n        contractOwner = payable(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * Function to receive native asset, msg.data must be empty.\r\n     */\r\n    receive() external payable {}\r\n\r\n    /**\r\n     * Fallback function is called when msg.data is not empty.\r\n     */\r\n    fallback() external payable {}\r\n\r\n    /**\r\n     * Gets the current native asset balance of contract.\r\n     */\r\n    function getBalance() public view returns (uint) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    /**\r\n     * Sets a new contract owner. Only callable by the current contract owner.\r\n     */\r\n    function setNewOwner(address newOwner) external {\r\n        require(msg.sender == contractOwner, \"only the current owner can change the owner\");\r\n        contractOwner = payable(newOwner);\r\n    }\r\n\r\n    /**\r\n     * Tax is equally divided by the contract owner and pool creator on each transaction.\r\n     */\r\n    uint256 contractTransactionTax = 10 ** 15;\r\n\r\n    /**\r\n     * This is the list of valid transaction taxes that can be set by the contract owner.\r\n     */\r\n    uint256[] validContractTransactionTaxes = [10**13, 10**14, 10**15, 10**16, 10**17];\r\n\r\n    /**\r\n     * Sets a new contractTransactionNax. Only callable by the current contract owner.\r\n     * The list of valid transaction taxes which can be set is validContractTransactionTaxes.\r\n     */\r\n    function setNewGlobalTax(uint8 newTaxIndexFromValidContractTransactionTaxes) external {\r\n        require(msg.sender == contractOwner, \"only the current owner can change the tax\");\r\n        require(newTaxIndexFromValidContractTransactionTaxes < validContractTransactionTaxes.length &&\r\n                newTaxIndexFromValidContractTransactionTaxes >= 0, \r\n                \"invalid newTaxIndexFromValidContractTransactionTaxes\");\r\n        contractTransactionTax = validContractTransactionTaxes[newTaxIndexFromValidContractTransactionTaxes];\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n    enum Rounding {\r\n        Down, // Toward negative infinity\r\n        Up, // Toward infinity\r\n        Zero // Toward zero\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\r\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\r\n     * with further edits by Uniswap Labs also under MIT license.\r\n     */\r\n    function mulDiv(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 denominator\r\n    ) internal pure returns (uint256 result) {\r\n        unchecked {\r\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\r\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\r\n            // variables such that product = prod1 * 2^256 + prod0.\r\n            uint256 prod0; // Least significant 256 bits of the product\r\n            uint256 prod1; // Most significant 256 bits of the product\r\n            assembly {\r\n                let mm := mulmod(x, y, not(0))\r\n                prod0 := mul(x, y)\r\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\r\n            }\r\n\r\n            // Handle non-overflow cases, 256 by 256 division.\r\n            if (prod1 == 0) {\r\n                return prod0 / denominator;\r\n            }\r\n\r\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\r\n            require(denominator > prod1);\r\n\r\n            ///////////////////////////////////////////////\r\n            // 512 by 256 division.\r\n            ///////////////////////////////////////////////\r\n\r\n            // Make division exact by subtracting the remainder from [prod1 prod0].\r\n            uint256 remainder;\r\n            assembly {\r\n                // Compute remainder using mulmod.\r\n                remainder := mulmod(x, y, denominator)\r\n\r\n                // Subtract 256 bit number from 512 bit number.\r\n                prod1 := sub(prod1, gt(remainder, prod0))\r\n                prod0 := sub(prod0, remainder)\r\n            }\r\n\r\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\r\n            // See https://cs.stackexchange.com/q/138556/92363.\r\n\r\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\r\n            uint256 twos = denominator & (~denominator + 1);\r\n            assembly {\r\n                // Divide denominator by twos.\r\n                denominator := div(denominator, twos)\r\n\r\n                // Divide [prod1 prod0] by twos.\r\n                prod0 := div(prod0, twos)\r\n\r\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\r\n                twos := add(div(sub(0, twos), twos), 1)\r\n            }\r\n\r\n            // Shift in bits from prod1 into prod0.\r\n            prod0 |= prod1 * twos;\r\n\r\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\r\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\r\n            // four bits. That is, denominator * inv = 1 mod 2^4.\r\n            uint256 inverse = (3 * denominator) ^ 2;\r\n\r\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\r\n            // in modular arithmetic, doubling the correct bits in each step.\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\r\n\r\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\r\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\r\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\r\n            // is no longer required.\r\n            result = prod0 * inverse;\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\r\n     */\r\n    function mulDiv(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 denominator,\r\n        Rounding rounding\r\n    ) internal pure returns (uint256) {\r\n        uint256 result = mulDiv(x, y, denominator);\r\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\r\n            result += 1;\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\n/**\r\n * Interface for ERC20 assets.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\r\n     * overridden;\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n}"
        }
    }
}